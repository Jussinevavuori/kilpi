---
title: Subject
---

:::caution
You should cache your `getSubject` function, as it will be called for each policy evaluation. Wrap your `getSubject` with e.g. `React.cache` to achieve this.
:::

The subject pattern is designed to encapsulate the current user, actor, or caller for passing them to Kilpi while evaluating policies.

In most use cases, the subject is equivalent to your user object (or an extended version of it with additional data). The terms "user" and "subject" may therefore be used interchangeably in this documentation.

### Example subject

```ts
type Subject = UserTypeFromMyAuthProvider & {
  permissions: string[];
}

// An example of a `getSubject` with an user object with permissions
const getSubject = cache((): Promise<Subject | null> => {
  const user = await getUserFromMyAuthProvider();
  if (!user) return null;
  const permissions = await getPermissionsFromMyDb(user.id);
  return Object.assign(user, { permissions })
});

export const Kilpi = createKilpi({ getSubject, ... })
```

### Provide extra data to policies

In addition to simply fetching the user object as your subject, you may also fetch any additional data, **if it is used in most policies**. This may include e.g. permissions, memberships, subscriptions or any other data that is used in most policies.

```ts
// subject.ts
const getSubject = cache(() => {
  const user = await getUserFromMyAuthProvider();
  if (!user) return null;

  // Fetch additional data
  const permissions = await db.getPermissions(user.id);
  const memberships = await db.getMemberships(user.id);
  const subscription = await db.getSubscription(user.id);

  return Object.assign(user, { permissions, permissions, subscription })
});
```

If you have data that is only used in a few policies, it should either be **fetched in the policy function** (preferred) or be passed down as the resource.

### Narrowing down the subject

Kilpi supports narrowing down the subject while evaluating policies. The most common use case for this is to ensure that a user is authenticated.

```ts
// Create subject-narrowing Policy constructor
const AuthedPolicy = Kilpi.as((subject: Subject | null) => {
  if (!subject) return null;
  return { subject };
});

// Create policy using the AuthedPolicy constructor
const policies = {
  example: AuthedPolicy.new((user) => {
    return isAdmin(user); // example
  })
}

// Apply policy to get narrowed down subject
const user: Subject = await Kilpi.authorize("example");

// Alternatively with `getAuthorization`
const user: Subject | null = await Kilpi.getSubject();
const authorization = await Kilpi.getAuthorization("example");
if (authorization.granted) {
  console.log(user.name); // User is defined
}
```

---

## Motivation for the subject pattern

### 1. Reduce boilerplate

By automatically providing the subject while evaluating policies, the caller does not have to worry about fetching the subject or passing it to the policy evaluation. Additionally, Kilpi can narrow down the type of the subject to reduce type-checking boilerplate.

```ts
// Without subject pattern
const user = await getUserFromMyAuthProvider();
await Kilpi.authorize(user, "docs:read", doc);
if (!user) {
  throw new Error("User not found");
}
console.log(user.name);

// With subject pattern (and narrowed down `user` type)
const user = await Kilpi.authorize("docs:read", doc);
console.log(user.name);
```

While this does make the API design less explicit, it is justified by the fact that in most applications it reduces the complexity and boilerplate of the implementation by a considerable amount.

### 2. Create auth-provider agnostic API

By bringing your own `getSubject` function you can use any auth provider you want.

This would allow you to easily change your auth provider without changing your authorization layer.
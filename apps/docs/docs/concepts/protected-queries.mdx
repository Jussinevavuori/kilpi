---
title: Protected queries
sidebar:
  order: 5
---

You can protect queries in any way you'd like, however Kilpi offers **protected queries** created using `Kilpi.$query` as a solution to co-locate your queries and authorization logic.

<Aside type="tip">

Co-locating queries and authorization logic makes maintaining and developing applications easier.

However, queries are easier to e.g. dedupe or cache if authorization logic is separate from the query function (the query should be kept **pure** â€” authorization logic is impure).

</Aside>

## Defining a protected query

To define a protected query, pass the query function as the first argument to `Kilpi.$query`. As the second argument, provide an object with the `authorize` method. The `authorize` function receives the `input` to the query as well as its `output` and the current `subject`. It then returns the output to which the subject is authorized.

```ts
const getPost = Kilpi.$query(
  // Query function
  async (id: string) => {
    return await db.posts.findById(id);
  },
  // Separate but co-located authorization which runs after the query
  {
    async authorize({ input: [id], output: post, subject }) {
      if (!post) return null;
      const { granted } = await Kilpi.posts.read(post).authorize();
      if (!granted) return null;
      return post;
    },
  },
);
```

You call the protected query using the `authorized` method as follows.

```ts
// Post or null
const post = await getPost.authorized("123");
```

<Aside type="note">

Instead of calling `getPost` directly, the `.authorized(...)` API makes the developer's intent to others (and future you) much clearer. It is immediately clear to the reader that `post` is safe to reveal to the user.

</Aside>

<Aside type="tip">

You can bypass the `authorize` function by calling `.unauthorized(...)`.

```ts
const post = await getPost.unauthorized("123");
```

This is useful when you e.g. need to query data which will not be exposed to the user or there is no subject, such as with cron jobs.

Again, this clearly communicates developer intent.

</Aside>

<Collapsible title="Visualization of how Kilpi.$query works">

The following pseudocode might make it easier to conceptualize how the `.authorized()` and `.unauthorized()` APIs work.

```ts
function unauthorized(input) {
  return query(input);
}

function authorized(input) {
  const output = query(input);
  const subject = getSubject();
  return authorize({ input, subject, output });
}
```

</Collapsible>

## Redacting data

A common issue with authorization is redacting data in a type-safe way. This is easy with the `Kilpi.$query` API.

```ts
const getUserDetails = Kilpi.$query(
  async (userId: string) => {
    return await db.users.findById(userId);
  },
  {
    async authorize({ output: user }) {
      if (!user) return null;
      const { granted } = await Kilpi.users.readPrivate(user).authorize();

      // Unauthorized: Only return public fields
      if (!granted) return { userId: user.id, name: user.name };

      // Authorized: Return also private fields
      return { userId: user.id, name: user.name, email: user.email };
    },
  },
);

// TS knows email is optional, as it may be redacted away
const userDetails = await getUserDetails.authorized(userId);
userDetails.email; // string | undefined
```

## Throwing on unauthorized

Commonly, instead of `return null` you want to throw and stop execution on unauthorized. Using the `assert()` API (or throwing your own exceptions) works very well with protected queries.

```ts "assert()"
const getPost = Kilpi.$query(..., {
  async authorize({ output: post }) {
    // Throws on unauthorized
    if (post) await Kilpi.posts.read(post).authorize().assert();
    return post;
  }
});
```

<Collapsible title="Why throw on unauthorized?">

If you have setup `onUnauthorizedAssert` handlers, throwing on unauthorized can remove a lot of boilerplate. See this example of a Next.js page using protected queries and throwing. Note how little `if (...) redirect(...)` authorization logic is required.

```ts ".authorized(id)" {4}
export default async function PostPage(props: PageProps<"/posts/[id]">) {
  const { id } = await props.params;

  const { subject } = await Kilpi.authed().authorize().assert();

  const post = await getPost.authorized(id);
  const comments = await listComments.authorized(id);

  return (...);
}
```

</Collapsible>

---
title: Usage on client
sidebar:
  order: 6
---

You can also use Kilpi on the client side with the `@kilpi/client` package which allows you to **fetch authorization decisions from the server**.

<Aside>
  All authorization decisions are evaluated on the server. This makest them are
  secure and trustable. This way they also can't expose any sensitive data and
  can access external data sources such as your authentication provider and
  backend.
</Aside>

---

## Setup

<Steps>
<Step>

### Install the `@kilpi/client` package

<Tabs syncKey="package-manager">
<Tab label="npm">

```bash
npm install @kilpi/client
```

</Tab>
<Tab label="yarn">

```bash
yarn add @kilpi/client
```

</Tab>
<Tab label="pnpm">

```bash
pnpm add @kilpi/client
```

</Tab>
<Tab label="bun">

```bash
bun add @kilpi/client
```

</Tab>
</Tabs>
</Step>
<Step>

### Setup environment variables

Create **public** environment variables (e.g. with `PUBLIC_`, `NEXT_PUBLIC_` or similar prefix to ensure they are included in the client bundle).

```bash
PUBLIC_KILPI_URL=http://localhost:3000/api/kilpi
PUBLIC_KILPI_SECRET=generate-secret
```

<GenerateSecretButton target="generate-secret"></GenerateSecretButton>
</Step>
<Step>

### Install EndpointPlugin

The Kilpi client requires an endpoint for fetching authorization decisions. Use the [EndpointPlugin](/docs/plugins/endpoint) from `@kilpi/core` to create an authorization endpoint. It exposes the `Kilpi.$createPostEndpoint()` function, which constructs a web-standard request-response function to use as your endpoint.

```diff lang="ts"
// kilpi.ts
import { createKilpi, EndpointPlugin } from "@kilpi/core";

export const Kilpi = createKilpi({
  ...,
+  plugins: [
+   EndpointPlugin({
+     secret: process.env.PUBLIC_KILPI_SECRET,
+     // Optional
+     getContext(request) { ... },
+     async onBeforeHandleRequest(request) { ... },
+     async onBeforeProcessItem(requestItem) { ... },
+   })
+ ]
})
```

Read more about the [EndpointPlugin](/docs/plugins/endpoint) for more information on the setup options.

<Aside type="tip">
  The endpoint automatically supports
  [SuperJSON](https://www.npmjs.com/package/superjson) serialization for sending
  dates and other non-JSON-safe values.
</Aside>

</Step>

<Step>

### Setup the authorization endpoint

Expose the endpoint using your framework of choice.

<Tabs syncKey="backend">
  <Tab label="Next.js (App router)">
    ```ts
    // app/api/kilpi/route.ts
    export const POST = Kilpi.$createPostEndpoint();
    ```
  </Tab>
  <Tab label="Hono">
    ```ts
    const endpoint = Kilpi.$createPostEndpoint();

    app.post('/api/kilpi', async (c) => await endpoint(c.req.raw));
    ```

  </Tab>
</Tabs>

<Aside>

More guides are coming, but as the `Kilpi.$createPostEndpoint()` returns a web-standard `(request: Request) => Promise<Response>` function, you can use it with any framework that supports web standards.

Alternatively, you can use an existing web-standard request-response adapter for your framework or create your own.

</Aside>

</Step>
<Step>

### Create your `KilpiClient` instance

Create your `KilpiClient` instance with `createKilpiClient`. This object is used to fetch authorization decisions from the server.

Optionally, pass `infer` for improved typesafety, and any plugins in `plugins`.

```ts
// kilpi-client.ts
import type { Kilpi } from "./kilpi.ts";

export const KilpiClient = createKilpiClient({
  // Infer subject and policies from server instance
  infer: {} as typeof Kilpi,
  // Connect to the endpoint
  connect: {
    endpointUrl: process.env.PUBLIC_KILPI_URL,
    secret: process.env.PUBLIC_KILPI_SECRET,
  },
});
```

<Aside type="tip">
  This works especially well with frameworks like Next.js, where you can import
  the type of the server-side instance on the client and use it infer the types,
  similarly as with [tRPC](https://trpc.io/).
</Aside>

</Step>
<Step>

### Fetch authorization decisions on the client

Now you can use `KilpiClient` to fetch authorization decisions from the server with a similar API as on the server.

`KilpiClient` automatically provides **request caching, batching and deduplication** for performance.

```ts
// Similar decision object as on the server
const decision = await KilpiClient.posts.edit(myPost).authorize();
```

</Step>

<Step>

### Use with your frontend framework

You can use `@kilpi/client` with your frontend framework of choice or use one of the provided plugins that provide e.g. components and other useful bindings for `KilpiClient`.

<Tabs syncKey="frontend">
  <Tab label="React">
#### React (client)

    Get utility hooks and components for client-side React with the [`@kilpi/react-client`
    package](/docs/plugins/react-client).

    ```tsx
    export function Component() {
      const { granted } = Kilpi.posts.create().useAuthorize();

      return <AuthorizeClient policy={Kilpi.posts.delete(post)}>
        <DeletePostForm />
      </AuthorizeClient>
    }
    ```

  </Tab>
</Tabs>

</Step>

</Steps>

---

## The `authorize()` API

The `authorize()` API is similar to the server-side `authorize()` API and it returns the same decision object. You can provide it additional options as shown below.

```ts
const decision = await KilpiClient.some.policy().authorize({
  abortSignal, // Provide a custom abort signal for the fetch call
});
```

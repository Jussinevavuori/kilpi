---
title: Authorizing
sidebar:
  order: 1
---

All server-side authorizations happen with the `authorize()` API.

## Authorization using `authorize()`

Reference a policy as e.g. `Kilpi.posts.edit(post)` and chain the `.authorize()` call. This evaluates the policy and returns an **authorization decision**.

```ts
const decision = await Kilpi.posts.edit(post).authorize();
if (decision.granted) {
  await db.posts.update(...);
}
```

The decision is either a **granted** or a **denied** decision.

```ts
{
  granted: true; // Signals "granted decision" (Discriminator)
  subject: TSubject; // The subject from the policy's Grant(subject)
} | {
  granted: false; // Signals "denied decision" (Discriminator)
  message?: string; // User-facing message, e.g. "You are not signed in"
  reason?: string; // System-facing reason, e.g. "UNAUTHORIZED"
  metadata?: unknown; // Optional metadata about the denial
}
```

<Aside type="tip">
  The decision is a [discriminated
  union](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions) based
  on the `granted` property. You have to check whether `granted` is `true` or `false` before
  accessing any other properties.
</Aside>

### Reference policies

To reference a policy, access it via dot notation and call it to "instantiate" it (optionally provide the object if the policy requires one).

```ts
export const Kilpi = createKilpi({
  // ...
  policies: {
    async never(subject) {...},                // Root-level policy
    posts: {                                   // Namespace
      async create(subject) {...},             // No object
      write: {                                 // Nested namespaces
        async edit(subject, post: Post) {...}, // Needs "Post" object
      }
    },
  },
});

// Use as follows
await Kilpi.never().authorize();
await Kilpi.posts.create().authorize();
await Kilpi.posts.write.edit(post).authorize();
```

### Context

If your `getSubject` adapter requires a `ctx` parameter (e.g. the current `Request`), you can pass it as follows.

```ts
await Kilpi.myPolicy.authorize({ ctx });
```

You can even override the `getSubject` adapter and pass your own subject.

```ts
await Kilpi.myPolicy.authorize({ subject: mySubject });
```

---

## Throw on unauthorized with `assert()`

In very many cases, you want to **throw on unauthorized**, especially when your framework supports throwing e.g. HTTP errors or redirections. For this purpose, you can use the `assert()` API as follows.

```ts
// Always returns a granted decision (or throws)
const { subject } = await Kilpi.myPolicy.authorize().assert();
```

An assertion **always returns a granted decision** or throws. For this reason, you can always destructure the `subject`.

By default, Kilpi throws a `KilpiUnauthorizedError`. To customize what is thrown, you can provide a global `onUnauthorized` handler.

```ts
export const Kilpi = createKilpi({
  // ...
  // Called when `.assert()` denies access.
  async onUnauthorized(denial) {
    console.log(`Denied: ${denial.message}`);
    throw new HttpForbiddenError();
  },
});
```

To override the default behavior, you can also provide an `onUnauthorized` callback to the assertion to run before the global handler.

```ts
await Kilpi.myPolicy.authorize().assert(async (denial) => {
  throw HttpRedirect("/sign-in");
});
```

Both handlers can even run side-effects before throwing. Additionally, you can register more custom `onUnauthorized` handlers with the [`Kilpi.$hooks.onUnauthorizedAssert` API](/docs/concepts/hooks).

---

## Different types of denials

The `Deny()` function can provide additional data about the reason of the denial, which can further be used to customize the behavior of `onUnauthorized`. See the following example.

```ts
const Kilpi = createKilpi({
  // ...
  policies: {
    posts: {
      // Only signed-in premium users can save posts
      async save(subject, post: Post) {
        if (!subject) {
          return Deny({ reason: "UNAUTHENTICATED" });
        }
        if (subject.tier !== "premium") {
          return Deny({
            reason: "NOT_SUBSCRIBED",
            metadata: { requiredTier: "premium" },
          });
        }
        return Grant(subject);
      },
    },
  },

  // Customize behavior based on reason
  async onUnauthorized(denial) {
    switch (denial.reason) {
      case "UNAUTHENTICATED":
        throw new HttpRedirect("/sign-in");
      case "NOT_SUBSCRIBED":
        throw new HttpRedirect(`/subscribe?tier=${denial.metadata?.requiredTier}`);
      default:
        throw new HttpForbiddenError();
    }
  },
});
```

---
title: Subject
sidebar:
  order: 3
---

**The subject** represents the current **user**† as well as any of their authorization-related data, such as permissions and memberships.

The current user is provided using the **`getSubject` adapter** to allow getting the subject from any system or authentication provider.

Kilpi calls `getSubject` for you as **authentication** always occurs before **authorization**. This removes unnecessary and duplicated authenticatin logic from your code.

<Aside>
  †**Subject ≈ user**, however the term **subject** is more commonly used in authorization systems,
  as it may also refer to e.g. external systems, applications or AI agents, which may access your
  application.
</Aside>

## Defining a `getSubject` adapter

Implement your `getSubject` adapter by passing it to `createKilpi`. It should call your authentication system or provider and return any value that represents the current subject or e.g. `null` if there is no authenticated subject.

```ts
export const Kilpi = createKilpi({
  async getSubject() {
    const user = await myAuthenticationProvider.getCurrentUser();
    if (!user) return null;
    return { id: user.id, name: user.name };
  },
  // ...
});
```

The `subject`'s type is automatically inferred by your `policies`.

<Aside type="tip">
  You can extract `getSubject` into its own function to infer the `Subject` type. This is especially useful when defining policies in separate objects.

```ts
async function getSubject() { ... }

export type Subject = Awaited<ReturnType<typeof getSubject>>;

export const Kilpi = createKilpi({ getSubject, ... })

```

</Aside>

### Context

Commonly, your `getSubject` may require additional **context** (e.g. the current `request`).

<Aside>
  When accepting the `ctx` parameter, ensure it is made optional with `?` as shown below.
</Aside>

```ts {2-4}
export const Kilpi = createKilpi({
  async getSubject(ctx?: Request) {
    if (!ctx) return null;
    const user = await myAuthenticationProvider.getCurrentUser(ctx);
    if (!user) return null;
    return { id: user.id, name: user.name };
  },
  // ...
});
```

You can then pass this `ctx` object when authorizing using the `authorize()` API.

```ts
Kilpi.some.policy.authorize({ ctx: request });
```

### Additional data

Very commonly, your subject has other authorization-related properties not received directly from your authentication provider. These include e.g. permissions, roles, and memberships. It is often practical and efficient to include them in your `getSubject` instead of fetching in policies.

```ts
export const Kilpi = createKilpi({
  async getSubject() {
    const user = await myAuthenticationProvider.getCurrentUser(ctx);
    if (!user) return null;
    const memberships = await db.listMembershipsForUser(user);
    return { ...user, memberships };
  },
  // ...
});
```

### Performance considerations and caching

Kilpi calls `getSubject` for you on every single `authorize()` call. Especially, if your `getSubject` is an expensive or slow function, you should consider caching it for each request.

<Aside type="warning">The cache **must not** leak the cached subject to other requests.</Aside>

This can be done in multiple ways, and some plugins (such as [`ReactServerPlugin`](/docs/plugins/react-server-plugin)) even automatically cache the subject.

<Collapsible title="Example of subject caching">

Simple example based on modifying the current `request` object.

```ts
async function getSubject(ctx?: Request & { cachedSubject?: Subject }) {
  if (!ctx) return null;

  // Cache hit
  if (ctx.cachedSubject) return ctx.cachedSubject;

  // Cache miss: Get subject and store it in cache
  const subject = await getCurrentUser(ctx);
  ctx.cachedSubject = subject;
  return subject;
}
```

Example using hooks and another per-request caching system, such as `React.cache`.

```ts
// Save to cache
Kilpi.$hooks.onSubjectResolved(async (event) => {
  await requestCache.set("subject", event.subject);
});

// Read from cache
Kilpi.$hooks.onSubjectRequestFromCache(async (event) => {
  const subject = await requestCache.get("subject", event.subject);
  if (subject) return { subject };
});
```

</Collapsible>

<br />

Additionally, a `@kilpi/subject-cache` package is currently in development which would allow you to wrap your application's entry point with an `async_hooks` based API which automatically caches your subject.

---
title: Subject
description: All you need to know about defining and using the subject in Kilpi.
sidebar:
  order: 3
---

**The subject** represents the current **user** as well as any of their authorization-related data, such as permissions and memberships.

<Aside>
  **Subject â‰ˆ user**, however the term **subject** is more commonly used in
  authorization systems, as it may also refer to e.g. external systems,
  applications or AI agents, which may access your application.
</Aside>

The current user is provided using the **`getSubject` adapter** to allow getting the subject from any system or authentication provider.

<Aside>
  Because authentication always comes before authorization, Kilpi reduces
  boilerplate and calls `getSubject` for you.
</Aside>

## Defining a `getSubject` adapter

Implement your `getSubject` adapter by passing it to `createKilpi`. It should call your authentication system or provider and return any value that represents the current subject or e.g. `null` if there is no authenticated subject.

```ts
export const Kilpi = createKilpi({
  async getSubject() {
    const user = await myAuthenticationProvider.getCurrentUser();
    if (!user) return null;
    return { id: user.id, name: user.name };
  },
  // ...
});
```

The `subject`'s type is automatically inferred by your `policies`.

<Aside type="tip">
  You can extract `getSubject` into its own function to infer the `Subject` type. This is especially useful when defining policies in separate objects.

```ts {3}
async function getSubject() { ... }

export type Subject = Awaited<ReturnType<typeof getSubject>>;

export const Kilpi = createKilpi({ getSubject, ... })
```

</Aside>

---

## Passing a context argument

Commonly, your `getSubject` may require additional **context** (e.g. the current `request`).

<Aside>
  When accepting the `ctx` parameter, ensure it is made optional with `?` as
  shown below.
</Aside>

```ts {2-4} "ctx"
export const Kilpi = createKilpi({
  async getSubject(ctx?: Request) {
    if (!ctx) return null;
    const user = await myAuthenticationProvider.getCurrentUser(ctx);
    if (!user) return null;
    return { id: user.id, name: user.name };
  },
  // ...
});
```

You can then pass this `ctx` object when authorizing using the `authorize()` API.

```ts "ctx: request"
await Kilpi.some.policy().authorize({ ctx: request });
```

<Collapsible title="Alternative to the ctx argument">
<Aside type="tip">
As an alternative to directly always providing the `ctx` argument, you may also pass it down via
`AsyncLocalStorage` if your runtime supports `async_hooks`. This requires some setup but may
reduce boilerplate.
</Aside>

Below is an example implementation using a global middleware to provide the `ctx`.

```ts
// app.ts
import { AsyncLocalStorage } from "async_hooks";

// Create an AsyncLocalStorage which can provide the `ctx`
export const ctxStorage = new AsyncLocalStorage<Context>();

// Provide the `ctx` in a middleware -- all code running inside
// this block has access to `const ctx = ctxStorage.getStore()`.
app.use(async (ctx, next) => {
  await ctxStorage.run(ctx, async () => {
    await next();
  });
});

// Later getSubject can use the ctxStorage to consume the ctx
async function getSubject() {
  const ctx = ctxStorage.getStore();
  if (!ctx) return null;

  // ...
}
```

</Collapsible>

---

## Additional data

Very commonly, your subject has other authorization-related properties not received directly from your authentication provider. These include e.g. permissions, roles, and memberships. It is often practical and efficient to include them in your `getSubject` instead of fetching in policies.

```ts "memberships" {5}
export const Kilpi = createKilpi({
  async getSubject(ctx?: Request) {
    const user = await myAuthenticationProvider.getCurrentUser(ctx);
    if (!user) return null;
    const memberships = await db.listMembershipsForUser(user);
    return { ...user, memberships };
  },
  // ...
});
```

---

## Accessing the subject

To access the subject, you can get it from the result of `authorize()` when the decision is granted (or when using `.assert()`) **or by using the `Kilpi.$getSubject()` utility**.

```ts
const subject = await Kilpi.$getSubject();
```

---

## Performance considerations and caching / deduping

Kilpi calls `getSubject` for you on every single `authorize()` call. Especially, if your `getSubject` is an expensive or slow function, you should consider caching it for each request (deduplicating).

<Aside type="warning">
  The deduplication cache **must not** leak the cached subject to other
  requests.
</Aside>

This can be done in multiple ways, and some plugins (such as [`ReactServerPlugin`](/docs/plugins/react-server)) even automatically cache the subject for each request.

<Collapsible title="Example: Cache subject with AsyncLocalStorage">

If your runtime supports `async_hooks` and you have access to your application's entrypoints (such as with a global middleware), you can use the following solution based on `AsyncLocalStorage`.

```ts
import { AsyncLocalStorage } from "async_hooks";

// Create AsyncLocalStorage for providing the cached subject
const subjectStorage = new AsyncLocalStorage<{
  value?: { subject: Subject };
}>();

// Store subject in AsyncLocalStorage
Kilpi.$hooks.onSubjectResolved((event) => {
  const store = subjectStorage.getStore();
  if (store) store.value = { subject: event.subject };
});

// Inject subject from cache before `getSubject` is called
Kilpi.$hooks.onSubjectRequestFromCache(() => {
  const store = subjectStorage.getStore();
  return store.value;
});

// Wrap your application entrypoint with the AsyncLocalStorage, e.g.
// using a middleware or similar solution
app.use(async (ctx, next) => {
  await subjectStorage.run({}, async () => {
    await next();
  });
});
```

</Collapsible>

<Collapsible title="Example: Cache subject in request object">

You might in some contexts with a mutable `request` object be able to store the subject directly in the request.

```ts
type SubjectCache = { subjectCache?: { subject: Subject } };

async function getSubject(
  ctx?: Request & {
    subjectCache?: { subject: Subject };
  },
) {
  if (!ctx) return null;

  // Cache hit
  if (ctx.subjectCache) return ctx.subjectCache.subject;

  // Cache miss: Get subject and store it in cache
  const subject = await getCurrentUser(ctx);
  ctx.subjectCache = { subject };
  return subject;
}
```

</Collapsible>

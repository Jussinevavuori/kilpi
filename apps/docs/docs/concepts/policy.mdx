---
title: Policies
sidebar:
  order: 2
---

**A policy** is an asynchronous function that receives the [**subject**](/docs/concepts/subject) and optionally an **object** and returns an **authorization decision**, either granted or denied using either `Grant(...)` or `Deny(...)`. Policies always run on the server.

Each policy corresponds to an **action** that can be taken in your application (optionally **on an object**), such as `posts.edit`.

## Defining policies

Define policies as the `policies` argument to `createKilpi`. Each policy function must either `return Grant(subject)` or `return Deny(...)`.

```ts
export const Kilpi = createKilpi({
  // ...
  policies: {
    // Root-level policy without object (1)
    async always(subject) {
      return Grant(subject);
    },

    // Nested policy with object
    posts: {
      async edit(subject, post: Post) {
        return subject?.id === post.userId ? Grant(subject) : Deny();
      },
    },

    // Deeply nested policy with object and data fetching
    organizations: {
      members: {
        async delete(subject, { orgId }: { orgId: string }) {
          if (!subject) return Deny();
          const role = await getUserRole(subject.id, orgId);
          if (role !== "admin") return Deny();
          return Grant(subject);
        },
      },
    },
  },
});
```

The `subject` type is automatically inferred, but the optional object type must be manually provided. Policies can be nested to any depth.

The policies are then referenced as e.g.

```ts
Kilpi.always();
Kilpi.posts.edit(myPost);
Kilpi.organizations.members.delete({ orgId });
```

<Aside type="tip">
  It is often smart to separate common logic into utility functions, such as `isAdmin(subject)` or
  `hasMembership(subject, orgId)`.
</Aside>

### Subject narrowing

Instead of returning `true`, the function returns `Grant(subject)`. This allows Kilpi to infer the narrowed down type subject type when authorizing.

```ts
export const Kilpi = createKilpi({
  // ...
  policies: {
    async authenticated(subject) {
      if (!subject) return Deny();
      return Grant(subject); // TS infers subject here is not null
    },
  },
});

// TS also infers that subject is not null here, no
// `if (decision.subject)` clauses required.
const decision = await Kilpi.authenticated().authorize();
if (decision.granted) {
  console.log(decision.subject.id);
}

// Similarly for assertions
const { subject } = await Kilpi.authenticated().authorize().assert();
console.log(decision.subject.id);
```

### Additional denial data

Similarly, instead of returning `false`, the policy function returns `Deny(...)`. The denial can be provided additional data about why the policy failed. All metadata is optional and you can simply `return Deny()` when no additional data is required.

```ts
export const Kilpi = createKilpi({
  // ...
  policies: {
    posts: {
      async edit(subject, post: Post) {
        if (!subject) {
          return Deny({
            message: "Unauthenticated",
            reason: "UNAUTHENTICATED",
          });
        }

        if (!subject.tier === "premium") {
          return Deny({
            message: "Not subscribed", // User-facing
            reason: "NOT_SUBSCRIBED", // System-facing
            metadata: {
              requiredTier: "premium", // System-facing
            },
          });
        }

        return Grant(subject);
      },
    },
  },
});

// Customize unauthorized behavior based on denial metadata
const decision = await Kilpi.postts.edit(post).authorize();
if (!decision.granted) {
  showMessage(decision.message);
  if (decision.reason === "NOT_SUBSCRIBED") {
    redirect(`/subscribe?tier=${decision.metadata?.requiredTier}`);
  }
}
```

### Data fetching

Policies are asynchronous and run on the server. This means they can fetch data from the database or any other source.

```ts
export const Kilpi = createKilpi({
  // ...
  policies: {
    posts: {
      // A free user can create at most 3 posts
      async create(subject) {
        if (!subject) return Deny();
        if (subject.tier === "premium") return Grant(subject);

        // Fetch # of posts from DB
        const postsCount = await db.countPostsForUser(subject.id);
        return postsCount < 3 ? Grant(subject) : Deny();
      },
    },
  },
});
```

<Aside type="tip">
  Remember to consider performance. The policy is evaluated (and therefore the fetch) during the
  `authorize()` call.
</Aside>

## Scaling policies to larger projects

Instead of defining all policies inside the `createKilpi` body, it is usually a more scalable approach to split them into multiple files.

<Aside type="tip">
When doing this, remember to add `as const satisfies Policyset<MySubject>` (with your `MySubject` type) to ensure the types are correct and the subject is automatically inferred.
</Aside>

```ts
// src/posts.policies.ts
import type { Policyset } from "@kilpi/core";
import type { MySubject } from "..."; // Your code

export const postPolicies = {
  async create(subject) {
    // ...
  },
  // ...
} as const satisfies Policyset<MySubject>;
```

```ts
// src/orgs.polciies.ts
import type { Policyset } from "@kilpi/core";
import type { MySubject } from "..."; // Your code

export const orgPolicies = {
  async create(subject) {
    // ...
  },
  // ...
} as const satisfies Policyset<MySubject>;
```

Then finally combine them in `createKilpi` as

```ts
import { postPolicies } from ".../posts.policies.ts";
import { orgPolicies } from ".../orgs.policies.ts";

export const Kilpi = createKilpi({
  // ...,
  policies: {
    posts: postPolicies,
    orgs: orgPolicies,
  },
});
```

You can take this nesting as deep as you want, e.g. `orgs.memberships.invites.create()`, by nesting `invitePolicies` under `membershipPolicies`, which is then under `orgPolicies`.
